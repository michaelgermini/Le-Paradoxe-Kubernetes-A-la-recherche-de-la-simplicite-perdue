# 3.1 Le constat : j'ai bâti un cluster à la main

> *"Le moment où vous regardez votre 'architecture simple' et réalisez qu'elle fait exactement ce que Kubernetes fait, mais moins bien."*

## L'illumination brutale

Vous pensiez fuir Kubernetes. Vous avez choisi l'alternative "simple" : Nomad, ou Render, ou votre propre stack Docker Compose sophistiquée. Puis vient le moment de l'audit technique, et la vérité vous frappe comme un camion.

### L'analogie du bricoleur qui reconstruit une voiture

Vous décidez de construire votre propre voiture parce que "les voitures modernes sont trop complexes". Vous commencez simple :
- Un moteur de tondeuse
- Des roues de vélo
- Un volant de kart

Au bout d'un an, vous avez :
- Un système de freinage ABS maison
- Une transmission automatique
- Un ordinateur de bord
- Une climatisation
- Un GPS intégré

Vous avez reconstruit une voiture moderne, mais avec plus de défauts et moins de fiabilité.

C'est exactement ce qui se passe avec les alternatives à Kubernetes.

## L'inventaire de votre "pile simple"

Prenons l'exemple d'une équipe qui a choisi "Nomad pour rester simple". Après 6 mois d'évolution, leur architecture ressemble à ça :

### La couche d'orchestration (Nomad)
- Jobs pour les web services
- Jobs pour les workers
- Jobs pour les cron tasks
- Jobs pour les migrations

### La couche de service discovery (Consul)
- Enregistrement automatique des services
- Health checks
- Load balancing entre instances

### La couche de secrets (Vault)
- Gestion des mots de passe base de données
- Clés API
- Certificats TLS
- Rotation automatique

### La couche de monitoring (Prometheus + Grafana)
- Métriques système
- Métriques applicatives
- Alertes automatiques
- Dashboards personnalisés

### La couche de logging (ELK Stack)
- Collecte centralisée des logs
- Recherche et filtrage
- Alertes sur les erreurs
- Analyse des tendances

### La couche réseau (Traefik)
- Routage intelligent
- SSL termination
- Rate limiting
- Circuit breakers

### La couche de stockage
- Volumes persistants
- Backups automatiques
- Snapshots
- Disaster recovery

## Le moment de la révélation

Vous listez tout ça sur un tableau blanc, et soudain vous réalisez :

**"J'ai reconstruit Kubernetes."**

Mais votre version maison a :
- Moins de stabilité
- Plus de code à maintenir
- Moins de fonctionnalités
- Plus de bugs
- Une documentation inexistante

## Les patterns reconnus

### Pattern 1 : L'abstraction fuite partout

Vous pensiez que Nomad cachait la complexité. Mais pour gérer les déploiements blue-green, vous implémentez des scripts bash complexes.

### Pattern 2 : Les workarounds s'accumulent

- "Nomad ne gère pas bien les secrets" → Ajout de Vault
- "Nomad n'a pas de service mesh" → Ajout de Consul Connect
- "Nomad manque de monitoring" → Ajout de Prometheus
- "Nomad n'a pas d'opérateurs" → Scripts personnalisés

### Pattern 3 : La dette technique explose

Chaque workaround ajoute :
- Code à maintenir
- Points de défaillance
- Complexité opérationnelle
- Documentation à écrire

### Pattern 4 : L'équipe s'épuise

Au lieu de développer des fonctionnalités, l'équipe passe son temps à :
- Déboguer des problèmes d'orchestration
- Écrire des scripts de déploiement
- Maintenir l'infrastructure maison
- Former les nouveaux arrivants

## L'ironie de l'économie réalisée

Vous avez choisi l'alternative pour "économiser" :
- Pas de formation Kubernetes coûteuse
- Pas de consultants externes
- Pas de migration complexe

Mais vous dépensez :
- Temps développeur sur l'infrastructure
- Bugs et downtime
- Recrutement plus difficile (qui connaît votre stack maison ?)
- Migration future plus coûteuse

## Les signes avant-coureurs (ignorés)

Vous auriez dû voir venir les problèmes quand :

### Signe 1 : Les fichiers de configuration deviennent complexes
Votre fichier Nomad simple de 20 lignes devient 200 lignes avec des templates, des conditions, des références croisées.

### Signe 2 : Les scripts s'accumulent
```bash
deploy.sh      # 50 lignes
rollback.sh    # 30 lignes
scale.sh       # 25 lignes
monitor.sh     # 40 lignes
backup.sh      # 35 lignes
```

### Signe 3 : L'équipe parle d'orchestration
Les discussions quotidiennes incluent :
- "Comment gérer les dépendances inter-services ?"
- "Qui s'occupe des health checks ?"
- "Comment faire du blue-green deployment ?"
- "Que faire en cas de split-brain ?"

### Signe 4 : Les incidents se multiplient
- Service A tombe, B ne sait pas qu'il est parti
- Scaling manuel cause des outages
- Les backups échouent silencieusement
- Les déploiements cassent l'application

## La paix qui vient avec l'acceptation

Le constat n'est pas une défaite. C'est une victoire. Vous avez appris que :

1. **La complexité est inévitable** pour les systèmes distribués
2. **Kubernetes résout ces problèmes** depuis des années
3. **Votre temps est plus précieux** que réinventer la roue
4. **L'écosystème mature** vaut les quelques heures d'apprentissage

Vous n'avez pas échoué. Vous avez juste pris le chemin le plus long pour arriver à la même conclusion que tout le monde.

---

*"Le constat n'est pas la fin du voyage. C'est le début de la sagesse."*

---

[Section suivante : 3.2 Analyse post-mortem](./3.2-analyse.md) | [Section précédente : Vue d'ensemble du chapitre](./README.md)

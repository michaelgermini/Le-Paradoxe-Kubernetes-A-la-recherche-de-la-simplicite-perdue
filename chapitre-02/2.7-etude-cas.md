# 2.7 Étude de cas : comment j'ai réinventé Kubernetes sans m'en rendre compte

> *"L'histoire vraie d'une équipe qui a passé 18 mois à reconstruire Kubernetes avec des Post-It et du duct tape."*

## Le contexte : une startup en pleine croissance

### L'entreprise
- **Secteur** : SaaS de gestion de contenu pour e-commerce
- **Taille équipe** : 15 personnes (8 devs, 3 ops, 4 business)
- **Stack initial** : Ruby on Rails monolithique + PostgreSQL
- **Infrastructure** : 2 serveurs AWS EC2

### Le problème
- Croissance rapide : +300% utilisateurs en 6 mois
- Temps de réponse dégradés (de 200ms à 2s)
- Downtimes fréquents lors des déploiements
- Équipe ops débordée

### La décision "raisonnable"
*"Kubernetes est overkill pour nous. Essayons Nomad, c'est plus simple."*

## Phase 1 : L'enthousiasme du départ (mois 1-3)

### Setup initial
```hcl
# job.nomad
job "rails-app" {
  datacenters = ["dc1"]

  group "web" {
    count = 2

    task "rails" {
      driver = "docker"
      config {
        image = "myapp:latest"
        port_map {
          http = 3000
        }
      }
      resources {
        cpu    = 500
        memory = 1024
      }
    }
  }
}
```

### Ce qui semblait parfait
- **Simplicité** : Un fichier HCL au lieu de YAML complexe
- **Rapidité** : Déploiement en 5 minutes
- **Évolutivité** : Scaling facile avec `nomad job scale`
- **Coût** : Pas de master nodes coûteux

### Les premiers succès
- Application déployée en production
- Scaling automatique lors des pics
- Downtimes réduits
- Équipe heureuse

## Phase 2 : Les premières fissures (mois 4-6)

### Problème 1 : Le monitoring absent

**Incident** : Application lente sans raison apparente.

**Investigation** : 2 heures passées à chercher dans les logs Nomad basiques.

**Solution bâclée** : Ajout de DataDog externe (50$/mois).

### Problème 2 : Les déploiements manuels

**Réalité** : `nomad job run` à la main = erreurs humaines.

**Solution** : Script bash maison.

```bash
#!/bin/bash
# deploy.sh
nomad job run job.nomad
nomad job status rails-app
echo "Déploiement terminé ? Vérifiez vous-même..."
```

### Problème 3 : Les secrets exposés

**Faille** : Mots de passe base de données en clair dans le HCL.

**Solution** : Vault ajouté (complexité +30%).

### Problème 4 : Le debugging distribué

**Incident** : Service down, pas d'erreur visible.

**Réalité** : Nomad ne donne pas d'info sur les dépendances inter-services.

## Phase 3 : L'accumulation des hacks (mois 7-12)

### L'architecture Frankenstein

Notre setup "simple" ressemblait maintenant à :

```
Nomad (orchestration)
├── Consul (service discovery)
├── Vault (secrets)
├── Prometheus (monitoring)
├── Grafana (dashboards)
├── ELK Stack (logs)
├── Traefik (ingress)
└── Script bash maison (déploiement)
```

**Complexité totale** : Équivalente à Kubernetes + 50% de code custom.

### Les coûts cachés

**Temps développeur** :
- 20% du temps sur l'infrastructure (vs 5% estimé)
- Scripts de déploiement à maintenir
- Debugging d'incidents complexes
- Formation des nouveaux arrivants

**Coûts cloud** :
- 3 outils externes = 200$/mois
- Over-provisionning pour compenser le manque d'auto-scaling intelligent

**Coûts business** :
- 2 downtimes majeurs = perte de clients
- Recrutement ops plus difficile
- Innovation ralentie

### Le moment du doute

**Discussion équipe** :
*"On passe plus de temps à maintenir Nomad + 6 outils que si on avait pris Kubernetes directement."*

**Réalisation** : Notre "solution simple" était devenue un monstre complexe.

## Phase 4 : La migration forcée (mois 13-18)

### Le déclencheur

**Incident critique** :
- Base de données corrompue pendant un déploiement
- 4h de downtime
- Client majeur perdu
- Ultimatum direction : "Résolvez ça ou on change de tech"

### La décision

*"On migre vers Kubernetes. C'est la seule façon de scaler sérieusement."*

### La migration : leçons apprises

#### Leçon 1 : Préparer l'équipe
- Formation K8s pour toute l'équipe (2 jours)
- POC sur cluster de test
- Migration d'un service non-critique d'abord

#### Leçon 2 : Automatiser au maximum
- GitOps avec ArgoCD
- Helm charts pour tous les services
- CI/CD complet automatisé

#### Leçon 3 : Monitoring dès le départ
- Prometheus + Grafana natifs
- Alerting automatique
- Observabilité complète

#### Leçon 4 : Infrastructure as Code
- Terraform pour tout
- Modules réutilisables
- Tests automatisés

### Les résultats

**Après migration** :
- Déploiements 10x plus fiables
- Temps de résolution incidents /10
- Scaling automatique intelligent
- Équipe ops réduite de 3 à 1 personne

**Leçon ultime** : "Les 18 mois avec Nomad nous ont coûté cher, mais nous ont appris à apprécier Kubernetes."

## L'analyse rétrospective

### Ce qui a mal tourné

#### 1. Surestimation de nos besoins
*"On n'est pas Google, on n'a pas besoin de K8s"* → Faux, on avait les mêmes problèmes.

#### 2. Sous-estimation de la complexité cachée
*"Nomad est plus simple"* → La complexité était déplacée, pas supprimée.

#### 3. Manque de vision long terme
*"Ça suffit pour maintenant"* → Les besoins évoluent plus vite qu'on pense.

#### 4. Résistance au changement
*"On ne veut pas réapprendre"* → L'apprentissage est un investissement, pas un coût.

### Ce qui était inévitable

#### 1. La croissance
Notre app a scale de 100 à 10000 utilisateurs. C'était prévisible.

#### 2. Les patterns universels
Load balancing, service discovery, secrets : mêmes problèmes partout.

#### 3. L'écosystème
Kubernetes a 10x plus d'outils et de communauté.

## Les conseils pour éviter notre erreur

### Pour les startups
1. **Évaluez l'échelle future** dès le départ
2. **Investissez dans les bonnes abstractions** tôt
3. **Acceptez la courbe d'apprentissage** de Kubernetes
4. **Construisez pour scale** , pas pour le minimum viable

### Pour les équipes
1. **Formez-vous continuellement**
2. **Expérimentez avec des POCs**
3. **Mesurez le coût total** des alternatives
4. **Ayez un plan B** réaliste

### Pour les managers
1. **Ne sous-estimez pas l'infrastructure**
2. **Priorisez la fiabilité** sur la vitesse initiale
3. **Investissez dans l'expertise** DevOps
4. **Acceptez que 'simple' évolue**

## La morale de l'histoire

**Vous finirez toujours par reconstruire les capacités de Kubernetes.**

La question n'est pas "Kubernetes ou pas ?", mais "Maintenant ou plus tard ?".

Maintenant : apprentissage structuré, migration contrôlée, dette minimale.

Plus tard : dette technique accumulée, migration d'urgence, coûts cachés.

Choisissez maintenant.

---

*"Notre histoire n'est pas un échec. C'est un rite de passage obligatoire pour tout·e DevOps qui se respecte."*

---

[Chapitre suivant : Chapitre 3 - Le Réveil](../chapitre-03/) | [Section précédente : 2.6 Les lois de la complexité émergente](./2.6-lois-complexite.md)

# 2.2 Nomad : le charme de la CLI minimaliste

> *"Nomad : parce que même les cowboys de l'Ouest avaient besoin d'un sheriff pour leurs conteneurs."*

## La promesse de la simplicité radicale

HashiCorp Nomad arrive sur la scène DevOps avec une proposition audacieuse : **tous les workloads sur une seule plateforme, avec une CLI simple**. Pas de Kubernetes complexes, pas de YAML verbeux, juste des commandes claires et un fichier de configuration minimal.

### L'analogie du sheriff dans une petite ville

Imaginez une petite ville de l'Ouest américain :
- Quelques cowboys (applications)
- Quelques saloons (services)
- Quelques banques (bases de données)

Au lieu d'une bureaucratie complexe, un seul sheriff gère tout : maintien de l'ordre, résolution des conflits, protection des citoyens. Nomad est ce sheriff pour vos conteneurs.

## L'architecture séduisante

### 1. Le cluster comme une seule entité

Contrairement à Kubernetes qui traite les workloads différemment (pods, services, ingress), Nomad traite tout comme des "jobs". Que ce soit :
- Un conteneur Docker
- Une application Java
- Un batch job
- Un service systemd

Tout est un job Nomad.

### 2. La CLI qui fait tout

```bash
# Déployer
nomad job run my-app.nomad

# Voir l'état
nomad job status

# Logs
nomad logs -job my-app

# Scaling
nomad job scale my-app 3
```

Pas besoin d'apprendre kubectl, helm, ou autre. Une seule commande pour tout.

### 3. Le fichier de job minimal

```hcl
job "web" {
  datacenters = ["dc1"]

  group "web" {
    count = 3

    task "server" {
      driver = "docker"

      config {
        image = "nginx"
        port_map {
          http = 80
        }
      }

      resources {
        cpu    = 500
        memory = 256
      }
    }
  }
}
```

**Comparé au YAML Kubernetes équivalent** : 50+ lignes vs 25 lignes en HCL.

## Les avantages qui séduisent

### Simplicité apparente
- Un seul outil pour tout
- Pas de distinction entre workloads
- Configuration déclarative mais concise
- Interface web optionnelle

### Polyvalence remarquable
Nomad gère :
- **Conteneurs** : Docker, Podman
- **Applications natives** : Java, Python, Go
- **VMs** : QEMU, VMware
- **Batch jobs** : Traitement de données
- **Services système** : Load balancers, proxies

### Écosystème HashiCorp intégré
- **Consul** pour le service discovery
- **Vault** pour les secrets
- **Terraform** pour l'infrastructure
- Tout fonctionne ensemble naturellement

### Performance et stabilité
- Plus léger que Kubernetes
- Moins de composants mobiles
- Plus prévisible en termes de ressources

## Les limites révélatrices

### 1. L'abstraction fuite quand ça compte

**Problème** : Nomad cache la complexité, mais elle refait surface pour les cas avancés.

**Exemple** : Le networking avancé nécessite toujours une compréhension profonde des concepts sous-jacents.

### 2. L'écosystème moins mature

**Problème** : Moins d'outils tiers, moins de documentation communautaire.

**Conséquence** :
- Debugging plus difficile
- Moins d'exemples pour les cas complexes
- Support communautaire limité

### 3. Les workloads complexes deviennent verbeux

**Problème** : Pour les applications microservices complexes, le fichier HCL devient aussi complexe que du YAML.

```hcl
# Un job complexe finit par ressembler à du Kubernetes
job "complex-app" {
  # ... 200 lignes de configuration
  group "api" {
    # ... configuration réseau
  }
  group "workers" {
    # ... configuration scaling
  }
  group "cache" {
    # ... configuration persistence
  }
}
```

### 4. Le scaling et la haute disponibilité

**Problème** : Nomad gère le scaling, mais pas avec l'intelligence de Kubernetes.

**Limites** :
- Pas de rolling updates aussi sophistiqués
- Moins d'options pour les stratégies de déploiement
- Health checks moins granulaires

## Le moment où Nomad ne suffit plus

Votre application évolue et soudain :

- **Multi-cloud** : Déploiement sur AWS, GCP, et Azure simultanément
- **Service mesh** : Gestion fine du traffic inter-services
- **Operators avancés** : Logique métier dans l'orchestrateur
- **Écosystème** : Intégrations avec Istio, Prometheus, etc.

Vous commencez à voir que Nomad, malgré sa simplicité, finit par avoir les mêmes limitations que les autres alternatives.

## L'ironie de Nomad

Nomad est **construit pour éviter la complexité de Kubernetes**, mais il révèle une vérité profonde :

**La complexité ne vient pas de l'outil. Elle vient du problème que l'outil résout.**

Nomad cache cette complexité mieux que Kubernetes, mais elle existe toujours. Quand vos besoins dépassent les cas simples, vous vous retrouvez face aux mêmes décisions architecturales.

## La leçon apprise

Nomad est excellent pour :
- Les équipes petites/moyennes
- Les workloads hétérogènes simples
- Les environnements où la simplicité prime

Mais il confirme que **toute orchestration sérieuse finit par rencontrer les mêmes défis fondamentaux** : networking, persistence, scaling, observability.

Nomad n'évite pas Kubernetes — il reporte juste le moment où vous en avez besoin.

---

*"Nomad prouve que la simplicité est possible, mais seulement tant que vos besoins restent simples."*

---

[Section suivante : 2.3 Render](./2.3-render.md) | [Section précédente : 2.1 Fly.io](./2.1-fly-io.md)

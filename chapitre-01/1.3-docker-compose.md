# 1.3 Docker Compose : la pente glissante de la simplicité

> *"Docker Compose : parce que gérer plusieurs conteneurs à la main, c'est pour les masochistes."*

## La solution apparente au problème des multiples conteneurs

Vous avez enfin admis que un conteneur unique ne suffit pas. Votre application a besoin :
- D'un frontend (React/Node.js)
- D'un backend API
- D'une base de données
- Peut-être d'un cache Redis

Au lieu de jongler avec 4 commandes `docker run`, vous découvrez Docker Compose. Et ça semble être LA solution parfaite.

## L'analogie du chef d'orchestre débutant

Imaginez que vous organisiez un concert. Au début, chaque musicien joue seul dans son coin :
- Le pianiste dans le salon
- Le guitariste dans la cuisine
- Le batteur au garage

C'est le chaos. Puis vous engagez un chef d'orchestre qui :
- Place chaque musicien à la bonne position
- Donne le tempo
- Coordonne les entrées

Docker Compose, c'est ce chef d'orchestre. Il prend vos conteneurs individuels et les fait jouer en harmonie.

## La promesse de simplicité

Docker Compose promet trois choses essentielles :

### 1. La déclaration plutôt que l'impératif

Au lieu de :
```bash
docker run -d --name db postgres
docker run -d --name redis redis
docker run -d --name app -p 3000:3000 --link db --link redis myapp
```

Vous écrivez un fichier `docker-compose.yml` :
```yaml
version: '3.8'
services:
  db:
    image: postgres
  redis:
    image: redis
  app:
    image: myapp
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis
```

Et tout se lance avec `docker-compose up`.

### 2. La gestion de projet

Un seul fichier définit toute votre stack. Plus de scripts shell compliqués, plus de documentation éparpillée.

### 3. L'environnement de développement partagé

Votre équipe peut maintenant cloner le repo et lancer `docker-compose up`. Finis les "ça marche chez moi".

## La descente progressive dans la complexité

Mais comme toute pente glissante, ça commence doucement et s'accélère.

### Étape 1 : Les bases (2-3 services)

Votre premier `docker-compose.yml` fait 20 lignes. C'est parfait :
```yaml
version: '3.8'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  api:
    image: node:16
    ports:
      - "3000:3000"
  db:
    image: postgres
```

### Étape 2 : Les variables d'environnement

Vos services ont besoin de configuration :
```yaml
services:
  api:
    environment:
      - DB_HOST=db
      - DB_PASSWORD=secret
      - REDIS_URL=redis://redis:6379
  db:
    environment:
      - POSTGRES_PASSWORD=secret
```

Mais où stocker ces secrets ? Dans le fichier ? Dans un `.env` ?

### Étape 3 : Les volumes pour la persistance

La base de données ne doit pas perdre ses données :
```yaml
services:
  db:
    volumes:
      - db_data:/var/lib/postgresql/data
  redis:
    volumes:
      - redis_data:/data

volumes:
  db_data:
  redis_data:
```

### Étape 4 : Les réseaux personnalisés

Pour plus de sécurité :
```yaml
services:
  web:
    networks:
      - frontend
  api:
    networks:
      - frontend
      - backend
  db:
    networks:
      - backend

networks:
  frontend:
  backend:
```

### Étape 5 : Les configurations avancées

Bientôt votre fichier fait 100 lignes :
```yaml
version: '3.8'
services:
  web:
    build:
      context: ./web
      dockerfile: Dockerfile
    volumes:
      - ./web:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
    ports:
      - "3000:3000"
    depends_on:
      - api
    networks:
      - frontend
    command: npm run dev

  api:
    build:
      context: ./api
    volumes:
      - ./api:/app
    environment:
      - DB_URL=postgres://user:pass@db:5432/mydb
    depends_on:
      - db
    networks:
      - backend
      - frontend

  db:
    image: postgres:13
    environment:
      - POSTGRES_DB=mydb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - db_data:/var/lib/postgresql/data
    networks:
      - backend

volumes:
  db_data:

networks:
  frontend:
  backend:
```

## Les problèmes émergents

Chaque ajout révèle de nouveaux problèmes :

### Problème 1 : La syntaxe YAML impitoyable

Un espace oublié ? Tout casse. Et les erreurs sont cryptiques :
```
ERROR: yaml: line 15: did not find expected key
```

### Problème 2 : Les dépendances circulaires

Service A dépend de B, B dépend de A. Compose ne vous aide pas.

### Problème 3 : Le développement vs production

Le même fichier pour dev et prod ? Mauvaise idée.

### Problème 4 : L'orchestration limitée

Compose gère le démarrage, mais pas :
- La scalabilité
- Les health checks
- Le load balancing
- Les rolling updates

### Problème 5 : La gestion des secrets

Les mots de passe en clair dans le YAML ? Pas idéal.

## Le moment où Compose ne suffit plus

Votre application grandit, et soudain :

- **Vous avez 10 services** : le fichier fait 200 lignes
- **Besoin de scaler** : `docker-compose up --scale api=3` ne marche pas vraiment
- **Déploiement en production** : Compose n'est pas fait pour ça
- **Monitoring** : Comment savoir si un service est healthy ?
- **Logs centralisés** : Difficile avec Compose

Vous commencez à entendre parler de **Kubernetes**. Au début, vous résistez : "C'est overkill pour mon petit projet."

Mais les forums, les articles, vos collègues : tous convergent vers la même conclusion.

## L'ironie de Compose

Docker Compose est à la fois :
- **La meilleure introduction à l'orchestration**
- **La pire chose qui puisse arriver** à un projet en croissance

Il vous donne le goût de la puissance de l'orchestration, mais ses limitations vous poussent inexorablement vers Kubernetes.

Compose est la drogue douce qui vous prépare au crack dur de K8s.

---

*"Docker Compose ne résout pas le problème de l'orchestration. Il le révèle, et vous rend accro à sa solution."*

---

[Section suivante : 1.4 Les volumes, variables et réseaux](./1.4-volumes-variables-reseaux.md) | [Section précédente : 1.2 L'illusion du service unique](./1.2-illusion-service-unique.md)

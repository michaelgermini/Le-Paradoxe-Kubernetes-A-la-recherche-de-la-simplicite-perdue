# 1.5 Anecdotes du terrain : "Juste un conteneur de plus..."

> *"Dans le DevOps, les anecdotes sont les cicatrices de guerre que nous montrons fièrement."*

## L'accumulation fatale des "juste un conteneur"

Chaque projet DevOps commence avec les meilleures intentions. "On garde ça simple." Puis vient la première demande : "Juste un conteneur de plus pour..."

Ces anecdotes, tirées du terrain, montrent comment l'accumulation progressive de conteneurs conduit inexorablement à l'orchestration.

## Anecdote 1 : Le projet de blog qui dérape

**Contexte** : Startup qui lance un simple blog WordPress.

**Phase 1 : L'innocence**
```yaml
version: '3.8'
services:
  wordpress:
    image: wordpress
    ports:
      - "80:80"
  db:
    image: mysql:5.7
```

*"Parfait ! Un blog en 5 minutes."*

**Phase 2 : Le cache pour les performances**
*"Le blog est lent. Ajoutons Redis !"*
```yaml
services:
  # ... existants
  redis:
    image: redis:alpine
```

**Phase 3 : L'envoi d'emails**
*"Besoin d'un service d'emails. Juste un conteneur Mailhog pour les tests."*
```yaml
services:
  # ... existants
  mailhog:
    image: mailhog/mailhog
    ports:
      - "8025:8025"
```

**Phase 4 : Les backups automatiques**
*"Il nous faut des backups. Un script cron dans un conteneur."*
```yaml
services:
  # ... existants
  backup:
    image: alpine
    command: sh -c "while true; do sleep 86400; done"
    volumes:
      - db_data:/db
      - ./backups:/backups
```

**Phase 5 : Le monitoring**
*"Comment savoir si ça marche ? Ajoutons Prometheus."*
```yaml
services:
  # ... existants
  prometheus:
    image: prom/prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
  grafana:
    image: grafana/grafana
```

**Résultat final** : 8 services, 47 lignes de YAML, des volumes partout, des réseaux personnalisés.

**Leçon** : Chaque "juste un conteneur" ajoute de la complexité qui s'accumule.

## Anecdote 2 : L'API qui avale tout

**Contexte** : API REST simple pour une app mobile.

**Le début** :
```yaml
version: '3.8'
services:
  api:
    build: .
    ports:
      - "3000:3000"
  db:
    image: postgres
```

**Les ajouts progressifs** :

*"Besoin de cache"*
```yaml
redis:
  image: redis
```

*"Pour les notifications push"*
```yaml
fcm:
  image: custom-fcm-relay
```

*"Pour les paiements"*
```yaml
stripe-webhook:
  image: stripe-cli
```

*"Pour les logs centralisés"*
```yaml
logstash:
  image: logstash
  volumes:
    - ./logstash.conf:/config/logstash.conf
```

*"Pour les métriques"*
```yaml
statsd:
  image: statsd/statsd
```

**Le moment de bascule** : L'équipe passe de 3 à 12 personnes. Soudain :
- Qui déploie quoi ?
- Comment tester localement ?
- Que faire si un service tombe ?
- Comment scaler l'API mais pas les webhooks ?

**La révélation** : "On dirait qu'on a recréé Heroku à la main."

## Anecdote 3 : Le staging qui devient production

**Contexte** : Application en développement avec un environnement staging.

**Setup initial** :
```yaml
version: '3.8'
services:
  web:
    build: .
  db:
    image: postgres
```

**L'évolution** :
- Tests automatisés → conteneur de test
- CI/CD → conteneur de build
- Preview environments → script qui crée des stacks temporaires
- Load testing → conteneur Artillery
- Security scanning → conteneur OWASP ZAP

**Le problème** : Le staging devient si complexe qu'il est indifférenciable de la production, mais sans la robustesse.

**La crise** : Incident en staging révèle que l'architecture ne scale pas. L'équipe doit tout réécrire.

## Anecdote 4 : Le monolithe conteneurisé

**Contexte** : Application legacy migrée vers Docker.

**La stratégie** : "Mettons toute l'app dans un conteneur pour simplifier."

Contenu du conteneur :
- Apache + PHP
- PostgreSQL
- Redis
- Cron jobs
- Scripts de backup
- Outils de monitoring

**Le script de démarrage** : 50 lignes de bash pour orchestrer le tout.

**Les avantages apparents** :
- "Un conteneur à déployer"
- "Pas de dépendances réseau"
- "Environnement cohérent"

**Les problèmes réels** :
- Redémarrage de 5 minutes
- Debug impossible
- Mise à jour risquée
- Monitoring inexistant

**La chute** : Un bug dans un cron job fait tout planter. L'équipe passe une nuit blanche à déboguer.

## Anecdote 5 : L'équipe distribuée

**Contexte** : Équipe de 8 développeurs, chacun sur sa machine.

**Le problème** : "Ça marche chez moi mais pas chez toi."

**Solutions essayées** :
1. Documentation détaillée → personne ne la lit
2. Script d'installation → fonctionne 50% du temps
3. Docker Compose → "Enfin !"

**Mais** : Chaque développeur ajoute son conteneur perso :
- Alice : conteneur de debug PHP
- Bob : conteneur de test de charge
- Charlie : conteneur de base de données locale supplémentaire
- Diane : conteneur de monitoring local

**Résultat** : Le `docker-compose.yml` fait 200 lignes, avec des profiles pour chaque développeur.

**La révélation** : "On passe plus de temps à gérer Docker qu'à coder."

## Les patterns communs identifiés

### Pattern 1 : L'accumulation linéaire
Chaque nouvelle fonctionnalité = un nouveau conteneur. Pas de refactoring, juste de l'ajout.

### Pattern 2 : Le conteneur comme excuse
"Je peux pas faire ça maintenant, je dois d'abord conteneuriser X."

### Pattern 3 : L'ignorance des coûts
Chaque conteneur a un coût : CPU, RAM, complexité de gestion.

### Pattern 4 : La dette technique reportée
"On ajoutera l'orchestration plus tard, quand ça deviendra critique."

### Pattern 5 : Le NIH syndrome (Not Invented Here)
Plutôt que d'utiliser un service managé, on crée un conteneur.

## La sagesse rétrospective

Toutes ces anecdotes suivent le même arc narratif :

1. **L'enthousiasme initial** : "Docker va tout simplifier !"
2. **L'accumulation progressive** : "Juste un conteneur de plus..."
3. **La complexité émergente** : "Pourquoi c'est si dur maintenant ?"
4. **La prise de conscience** : "On a peut-être besoin de quelque chose de plus..."
5. **La migration** : "Kubernetes, hein ? Parlons-en."

Ces histoires ne sont pas des échecs. Ce sont des rites de passage obligés dans l'apprentissage du DevOps moderne.

---

*"Chaque 'juste un conteneur de plus' est un pas vers la maturité. Le problème n'est pas les conteneurs, mais l'illusion qu'ils restent simples."*

---

[Section suivante : 1.6 Pourquoi tout projet finit par nécessiter un orchestrateur](./1.6-pourquoi-orchestrateur.md) | [Section précédente : 1.4 Les volumes, variables et réseaux](./1.4-volumes-variables-reseaux.md)
